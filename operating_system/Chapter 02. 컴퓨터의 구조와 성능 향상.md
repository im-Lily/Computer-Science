## **Chapter 02. 컴퓨터의 구조와 성능 향상**

------

### 01. 컴퓨터의 기본 구성

1. 하드웨어의 구성

   1. 컴퓨터는 필수 장치인 중앙처리장치(CPU)와 메인메모리와 주변장치인 입출력, 저장장치로 구성된다.
   2. 제1저장장치 : 휘발성 메모리인 "램" / 제2저장장치 : 비휘발성 메모리인 "롬", "플래시메모리", "하드디스크", "USB 메모리"

   - CPU와 메모리
     - CPU는 명령어를 해석하는 장치이며, 메모리는 작업에 필요한 프로그램과 데이터를 저장하는 장소로 바이트 단위로 분할된 공간을 주소로 구분한다.
   - 입출력장치
     - 입력장치 : 외부의 데이터를 컴퓨터에 입력하는 장치 - 키보드, 마우스, 스캐너
     - 출력장치 : 컴퓨터에서 처리한 결과를 사용자가 원하는 형태로 출력하는 장치 - 프린터, 모니터, 스피커
   - 저장장치
     - 저장장치는 메인메모리에 비해 느리지만 저렴하고 용량이 크고, 데이터를 영구적으로 저장한다.
   - 메인보드
     - 메인보드는 CPU와 메모리 등 다양한 부품을 연결하는 커다란 판으로 일정한 규칙에 따라 각 장치에 데이터를 전송한다.

2. 폰노이만 구조

   1. 폰노이만 구조는 CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조를 말하며 모든 프로그램은 메모리에 올라와야 실행할 수 있다.
   2. 운영체제도 프로그램이기 때문에 메모리에 올라와야 실행 가능하다.

3. 하드웨어 사양 관련 용어

   1. 클록  :  CPU의 속도와 관련된 단위
      1. CPU가 작업할 때 만들어내는 박자를 클록틱이라고 하며, 메인보드의 클록이 틱을 보낼 때마다 데이터를 보내거나 받는다.
   2. 헤르츠 : 클록틱이 발생하는 속도를 나타내는 단위
      1. 1초에 클록틱이 몇 번 발생하는지를 나타낸다.
      2. 3.4GHz는 1초에 클록틱이 3,400,000,000번 발생하여 CPU가 1초에 약 34억 번의 연산을 할 수 있음을 의미
   3. 시스템 버스(FSB) : 메모리와 주변장치를 연결하는 버스
      1. 메인보드의 속도와 동일하게 작동
   4. CPU 내부 버스(BSB) : CPU 내부에 있는 장치를 연결하는 버스
      1. 속도는 CPU의 클록과 같아서 시스템 버스보다 훨씬 빠르다.

------

### **02. CPU와 메모리**

1. CPU의 구성과 동작

   1. 산술논리 연산장치, 제어장치, 레지스터로 구성

      1. 산술논리 연산장치 : CPU에서 데이터 연산
      2. 제어장치 : CPU에서 작업 지시
      3. 레지스터 : CPU내에 데이터 임시 보관

   2. CPU 명령어 처리 과정

      ```
      int D2 = 2, D3 = 3, sum;
      sum = D2 + D3;
      ```

      ```
      01    LOAD 0x100 r2;
      02    LOAD 0x120 r3;
      03    ADD r5, r2, r3;
      04    MOVE r5, 0x160;
      ```

      ```
      01 : 메모리 0x100에 있는 데이터를 r2에 로드한다.
      02 : 메모리 0x120에 있는 데이터를 r3에 로드한다.
      03 : r2와 r3의 데이터의 값을 ADD한 후 r5에 넣는다.
      04 : r5에 있는 값을 메모리 0x160에 옮긴다.
      ```

   - CPU는 필요한 데이터를 메모리에서 가져와 레지스터에 저장하고 산술논리 연산장치를 이용하여 연산 후, 그 결과를 다시 레지스터에 저장하였다가 메모리로 옮긴다.

   c. 레지스터의 종류

   1. 사용자 가시 레지스터 (사용자 프로그램에 의해 변경 가능)
      1. 데이터 레지스터(DR) : CPU가 명령어를 처리하는 데 필요한 데이터를 임시로 저장하는 범용 레지스터
      2. 주소 레지스터(AR) : 데이터 또는 명령어가 저장된 메모리 주소 저장
   2. 사용자 불가시 레지스터 (임의로 변경 불가능) = 특수 레지스터
      1. 프로그램 카운터(PC) : 다음에 실행할 명령어의 위치 정보 저장
      2. 명령어 레지스터(IR) : 현재 실행 중인 명령어 저장
      3. 메모리 주소 레지스터(MAR) : 메모리 관리자가 접근해야 할 메모리 주소 저장
      4. 메모리 버퍼 레지스터(MBR) : 메모리 관리자가 메모리에서 가져온 데이터 임시 저장
      5. 프로그램 상태 레지스터(PSR) : 연산 결과 저장

   d. 버스의 종류

   1. 제어버스
      1. 제어장치와 연결된 버스로, CPU가 메모리와 주변장치에 제어 신호를 보내기 위해 사용
      2. 메모리와 주변장치에서도 작업이 완료되거나 오류 발생 시 제어 신호를 보내기 때문에 양방향
   2. 주소 버스
      1. 메모리 주소 레지스터와 연결된 버스로, 메모리나 주변장치에 데이터를 읽거나 쓸 때 위치정보를 보내기 위해 사용하며 단방향
      2. 데이터 버스 : 메모리 버퍼 레지스터와 연결된 버스로, 데이터 이동 양방향

2. 메모리의 종류와 부팅

   1. 메모리 종류

      1. 읽거나 쓸 수 있는 램 / 읽기만 가능한 롬
         1. 휘발성 메모리
            1. DRAM : 일정 시간이 지나면 데이터가 사라짐 → 재생 필요 / 메인메모리에 사용
            2. SRAM : 전력이 공급되는 동안에는 데이터 보관 가능 → 재생 불필요 / 고속 메모리(캐시)에 사용
            3. SDRAM : 클록틱이 발생할 때마다 데이터 저장
         2. 비휘발성 메모리
            1. 플래시 메모리, SSD

   2. 메모리 보호

      1. 일반적으로 메모리는 운영체제 영역과 사용자 영역으로 구분되어 있으며, 사용자 작업이 진행되는 동안 운영체제 작업이 중단된다. 이 때, 사용자의 작업으로부터 메모리를 보호해야 한다.
      2. CPU는 현재 진행 중인 작업의 메모리 시작 주소를 경계 레지스터에 저장한다.
      3. 현재 진행 중인 작업이 차지하고 있는 메모리의 크기를 한계 레지스터에 저장한다.
      4. 사용자의 작업이 진행되는 동안 두 레지스터의 범위를 벗어나는지 점검하며 메모리를 보호한다.
      5. 만약, 두 레지스터의 값을 벗어날 경우 인터럽트가 발생하고 모든 작업이 중단되어 운영체제는 해당 프로그램을 강제 종료시킨다.

   3. 부팅

      1. 폰노이만 구조에 따라 프로그램인 운영체제도 메모리에 올라와야 실행이 되는데 이 과정을 부팅이라고 한다.

      - 부팅 과정

        ![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e4a09f87-16b0-4c08-8b49-4d91de34616b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211229%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211229T012118Z&X-Amz-Expires=86400&X-Amz-Signature=21e8dc5ebdb2ed8b6d9fe5b0459175c9f30a9fe204d403a3c37b37220477d259&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

      ```
      1. 사용자가 컴퓨터 전원을 키면 ROM에 저장된 BIOS가 실행된다.
      2. BIOS는 CPU, 메모리, 하드디스크 등 주요 하드웨어 점검을 한다.
      3. 이상 없을 경우 하드디스크의 MRB(Master Boot Record)에 저장된 프로그램을 메모리에 가져와 실행한다.
      MBR은 하드디스크의 첫 번째 섹터를 가리키며, 운영체제를 실행하기 위한 코드인 bootstrap이 저장되어 있다.
      4.bootstrap이 메모리에 올라오면 하드디스크에 저장된 운영체제를 메모리로 불러온다.
      ```

------

### 03. 컴퓨터 성능 향상 기술

CPU의 속도는 BSB의 속도와 같은데, 메모리를 비롯한 주변 장치의 속도인 FSB가 BSB의 속도를 따라가지 못한다.

즉, 장치 간 속도 차이가 발생 ⇒ 속도 차이 개선 및 시스템 작업 속도 올리기 위한 기술 필요

1. 버퍼

   1. 버퍼의 개념
      1. 속도에 차이가 있는 두 장치 사이에서 그 차이를 완화하는 역할
      2. 입출력장치에서 데이터를 가져오는 경우, 일정량의 데이터를 모아 옮겨 속도의 차이를 완화하는 장치
      3. 하드디스크에는 메모리 버퍼가 존재함
   2. 스풀
      1. CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적 버퍼
      2. 프린터에 사용되는 스풀러 - 인쇄 내용을 순차적으로 출력하는 소프트웨어
      3. 인쇄 내용을 스풀러에 저장해 작업과 프린팅을 독립시키도록 함

   ⇒ 스풀러는 버퍼의 일종

   ⇒ 하지만, 버퍼는 어떤 프로그램이 사용하는 데이터든 버퍼가 차면 이동이 시작됨, 스풀러는 한 인쇄물 완료까지 다른 인쇄물 끼어들 수 없어 프로그램 간 배타적

2. 캐시

   1. 캐시의 개념

      1. 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 장소
      2. CPU가 사용할 것으로 예상되는 데이터를 미리 가져다주는 '미리 가져오기' 기능
      3. FSB 속도와 같은 메모리, BSB 속도와 같은 CPU의 속도 차이 완화
      4. 캐시는 메모리 내용 중 일부 미리 가져오고, CPU는 메모리에 접근 전 캐시를 먼저 방문해 원하는 데이터 있는지 찾아봄
         1. 캐시 히트: CPU가 캐시에서 원하는 데이터를 찾음 ⇒ '캐시 적중률' 계산 가능
         2. 캐시 미스: 캐시에 원하는 데이터가 없어 메모리를 찾아감
         3. 캐시 적중률을 높이려면, 캐시의 크기 늘리기 or 현재 위치에 가까운 데이터가 멀리 있는 데이터보다 사용될 확률이 높다는 '지역성 이론' 적용

   2. 즉시 쓰기와 지연 쓰기

      메모리에서 데이터를 임시로 가져오는 캐시 - 캐시의 데이터 변경되면 메모리 데이터 또한 변경 되어야함

      1. 즉시 쓰기 - Write Through
         1. 캐시 데이터 변경시 즉시 메모리에 반영하는 방식
         2. 빈번한 데이터 전송으로 성능 느려지지만, 항상 최신값 유지로 인해 정전에도 데이터 잃지 않음
      2. 지연 쓰기 - Write Back
         1. 캐시 데이터 변경시 변경 내용을 모아 주기적으로 메모리에 반영(카피백 방식)
         2. 데이터 전송 횟수 줄어 성능 향상, 메모리와 캐시 데이터 사이 불일치 발생 가능

   3. L1 캐시와 L2 캐시

      프로그램 명령어 - 어떤 작업 할지 나타내는 '명령어 부분'과 작업 대상인 '데이터 부분'

      캐시 - 명령어와 데이터 구분 없이 모든 자료 가져오는 '일반 캐시', 구분하는 '특수 캐시'

      1. L1 캐시(Level 1 Cache)
         1. CPU 레지스터에 직접 연결된 명령어 캐시와 데이터 캐시
      2. L2 캐시(Level 2 Cache)
         1. 메모리와 연결된 일반 캐시

3. 저장장치의 계층 구조

   가격과 컴퓨터 성능 사이의 타협점 - 저장장치의 계층 구조

4. 인터럽트

   1. 인터럽트의 개념

      1. 오늘날 컴퓨터는 많은 주변장치 ⇒ CPU가 모든 입출력에 관여하면 작업 효율 감소
      2. 이를 해결하기 위한 인터럽트 방식
      3. CPU작업과 저장장치의 데이터 이동을 독립적으로 운영해 시스템 효율 높임

   2. 인터럽트 방식의 동작 과정

      > 1. CPU가 입출력 관리자에게 입출력 명령을 보낸다. 
      > 2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다 놓거나, 메모리에 있는 데이터를 저장 장치로 옮긴다.  
      > 3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호를 CPU에 보낸다.

      인터럽트: 입출력 관리자가 CPU에 보내는 완료 신호

      다양한 주변장치를 CPU에 구분해 알려주기 위한 '인터럽트 번호' - 윈도우에선 IRQ

      인터럽트를 하나의 배열로 만든 인터럽트 벡터를 사용함

   3. 직접 메모리 접근(DMA - Direct Memory Access)

      메모리는 CPU만 접근 권한을 가진 작업공간 - 입출력 관리자는 접근 불가

      ⇒ 입출력 관리자는 CPU의 허락 없이 메모리에 접근할 수 있는 권한필요 = 직접 메모리 접근(DMA)

   4. 메모리 매핑 입출력

      CPU가 사용하는 데이터와 입출력 장치가 사용하는 데이터가 섞이게 되어, 직접 메모리 접근을 사용하면 메모리가 복잡해진다

      따라서, CPU를 위한 메모리 공간과 직접 메모리 접근을 위한 데이터 공간을 분리

      ⇒ 메모리의 일정 공간을 입출력에 할당하는 기법이  '메모리 매핑 출력'

   5. 사이클 훔치기

      CPU와 직접 메모리 접근이 동시에 메모리 접근시, CPU의 작업 속도보다 입출력장치의 속도가 느리기 때문에, 보통 CPU가 메모리 사용 권한 양보

      ⇒ 이러한 상황을 '사이클 훔치기'라 부름

------

### 04. 병렬 처리

CPU 성능향상 - 클록 높이기(발열 문제) or 캐시 늘리기(비용 문제)

⇒ 코어를 여러개 만들거나, 동시 실행 가능 명령 개수를 늘리기

1. 병렬 처리(Parallel processing)의 개념

   1. 동시에 여러개의 명령을 처리하여 작업의 능률을 올리는 방식
   2. 겹치지 않는 작업을 하나의 코어가 여러 개의 스레드를 이용해 작업 처리 = 파이프 라인 기법
      1. 스레드: CPU가 처리할 수 있는 작업의 단위
      2. 멀티스레드: 여러 개의 스레드를 동시에 처리하는 방법
   3. 복수 이상 개의 CPU 코어를 두어 동시에 작업을 처리 = 슈퍼 스칼라 기법

2. 병렬 처리 시 고려 사항

   1. 상호 의존성이 없어야 병렬 처리가 가능하다
      1. 앞뒤 단계 간 상호 의존적 명령어 사용시 병렬 처리 불가
   2. 각 단계의 시간을 거의 일정하게 맞춰야 병렬 처리가 원만하게 이루어진다
      1. 긴 시간이 걸리는 작업에서 병목 현상이 발생해 전체 작업 시간이 늘어남
   3. 전체 작업 시간을 몇 단계로 나눌지 잘 따져보아야 한다
      1. 작업을 N개로 쪼갰을 때 N: 병렬 처리의 깊이 - 깊이 1이면 병렬처리 없음
      2. 동시 처리 작업의 개수를 잘 따져보아 병렬 처리의 깊이를 설정해야함
      3. 작업 너무 많이 나누면, 작업 이동과 새 작업 불러오기에 시간 많이 걸림(오버헤드)

3. 병렬 처리 기법

   CPU 내에서 명령어는 제어장치가 처리 ⇒ 명령어 가져와 해석 후 실행, 결과 저장 반복 - 하나의 스레드 ⇒ CPU클록과 연동 한 클록에 한 번씩 이루어짐

   > 명령어 패치: 다음에 실행할 명령어를 명령어 레지스터에 저장한다 명령어 해석: 명령어를 해석한다 실행: 해석한 결과를 토대로 명령어를 실행한다 쓰기: 실행된 결과를 메모리에 저장한다

   1. **파이프라인 기법**

      CPU사용 극대화 위해, 명령을 겹쳐 실행하는 방법 ⇒ 하나의 코어에 여러 개의 스레드를 사용하는 것

      명령어 여러 단계 분할 후, 각 단계 동시 처리하는 하드웨어를 독립적으로 구성

      파이프라인 기법엔 3가지의 파이프 라인의 위험이 존재함

      1. 데이터 위험

         데이터의 의존성 때문에 발생 - 명령어 간 사용하는 자원의 의존성 문제

         ⇒ 파이프라인의 명령어 단계를 지연하여 해결

      2. 제어 위험

         프로그램 카운터 값을 갑자기 변화시켜 발생하는 위험 - if문 혹은 goto 문 같은 분기문에 의해 발생

         첫 명령어 실행 후 분기하면 다른 문장으로 이동하게 되어 현재 동시처리되고 있는 명령어들이 쓸모 없어짐

         ⇒ 분기 예측이나 분기 지연 방법으로 해결

      3. 구조 위험

         서로 다른 명령어가 같은 자원에 접근하려 할 때 발생하는 문제

         ⇒ 해결하기 어렵다 알려져 있음

   2. **슈퍼스칼라 기법**

      파이프라인을 처리할 수 있는 코어를 여러 개 구성해, 복수의 명령어가 동시에 실행되도록 하는 방식

      처리되는 명령어가 상호 의존성 없이 독립적이어야 하며, 이를 위한 처리도 컴파일러에서 이루어지도록 조정해야 함

      오늘날의 CPU 대부분 슈퍼스칼라 기법 사용

   3. **슈퍼파이프라인 기법**

      파이프라인 기법을 강화한 것 - 파이프라인 각 단계를 세분하여 한 클록 내에 여러 명령어 처리

      크레이 슈퍼컴퓨터의 CPU에서 사용

   4. **슈퍼파이프라인 슈퍼스칼라 기법**

      슈퍼파이프라인 기법을 여러개의 코어에서 동시에 수행하는 방식

   5. **VLIW 기법**

      CPU가 병렬처리를 지원하지 않을 경우, 소프트웨어적으로 병렬 처리하는 방식

      동시 수행 가능한 명령어를 컴파일러가 추출 후 하나의 명령어로 압축 실행

      동시에 처리하는 명령어의 개수가 적고, 컴파일시 병렬 처리가 이루어짐

------

### 05. [심화학습] 무어의 법칙과 암달의 법칙

1. **무어의 법칙**

   CPU의 속도가 24개월마다 2배 빨라진다는 무어의 법칙(Moore's law)

   현재 CPU는 자체 발열 문제로 적용되지 않음

   ⇒ CPU의 핵심 부품인 코어의 개수를 늘리는 방식으로 처리 중

2. **암달의 법칙**

   컴퓨터 시스템 일부를 개선시, 전체 시스템에 미치는 영향과의 관계 수식

   메모리를 비롯한 주변장치의 발전 속도와 CPU의 발전 속도는 차이가 존재

   ⇒ 컴퓨터 내 CPU만 단독으로 성능을 늘려도, 전체 컴퓨터 성능이 2배 증가하진 않음

------

Reference

- https://math-coding.tistory.com/category/Operating%20System