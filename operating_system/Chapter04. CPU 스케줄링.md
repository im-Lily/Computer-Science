## Chapter04. CPU 스케줄링

------

### 01. 스케줄링의 개요

스케줄링은 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 말한다. CPU 스케줄링은 규모에 따라 고수준, 중간 수준, 저수준 스케줄링으로 구분된다.

1. 스케줄링의 단계

   - 고수준 스케줄링(장기 스케줄링 or 작업 스케줄링 or 승인 스케줄링)
     - 가장 큰 틀에서 이루어지는 CPU 스케줄링으로 시스템 내의 전체 작업 수 조절
     - 작업 요청 시 승인 여부를 결정함 ⇒ 시스템 내에서 동시에 실행 가능한 프로세스의 총 개수(멀티프로그래밍 정도) 결정
   - 중간 수준 스케줄링
     - 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하 방지
     - 저수준 스케줄링이 원만하게 이루어지도록 완충(buffer)하는 역할
   - 저수준 스케줄링(단기 스케줄링)
     - 가장 작은 단위의 스케줄링 - 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
     - ex) 준비 상태에 있는 프로세스 → 실행 상태 → 대기 상태 대기 상태 → 준비 상태로 보냄

2. 스케줄링의 목적

   모든 프로세스가 공평성을 유지하며 안정적으로 작업하도록 하는 것 ⇒ 보통 모든 프로세스가 공평하게 CPU를 할당받지만 시스템의 안정성과 효율성을 높이기 위해 우선순위에 따라 CPU 배정

   시스템 자원을 효율적으로 배분하여 전체적인 시스템 성능 향상

   시스템의 안정성과 효율성을 위해 우선순위 높은 프로세스(운영체제 프로세스, 우선순위 높은 일반 프로세스 등)를 먼저 CPU 배정을 받도록 해, 일정 부분 공평성을 희생함

   - 공평성 : 모든 프로세스가 공평하게 자원 배정
   - 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에 우선권 제공
   - 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원 보호
   - 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치
   - 반응 시간 보장 : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야함
   - 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되어서는 안됨

------

### 02. 스케줄링 시 고려 사항

1. 선점형 스케줄링과 비선점형 스케줄링

   1. 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있음 - 실행 상태의 프로세스 작업을 중단시키고 새로운 작업 시작

      1. 문맥 교환 같은 부가작업으로 낭비 발생
      2. 하나의 프로세스가 CPU를 독점할 수 없기 때문에 대화형 or 시분할 시스템에 적합 ⇒ 저수준 스케줄러

      ex) 인터럽트 처리 → CPU가 인터럽트를 받으면 현재 실행 중인 작업을 중단하고 커널을 깨워서 인터럽트 처리 후 완료 시 원래 작업으로 돌아감

   2. 비선점형 스케줄링 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없음

      1. 선점형 스케줄링보다 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비가 적음
      2. CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오래 기다리게 되어 전체 시스템의 처리율이 떨어짐 ⇒ 일괄 작업 시스템

   - 선점형 스케줄링 방식의 스케줄러에 비선점형 프로세스 존재 가능 - 시스템 백업 프로세스 ⇒ 비선점형과 선점형 프로세스의 혼재 ⇒ 비선점형 프로세스 중요도 낮춰, 선점형 프로세스에 영향을 덜 미치도록 함

2. 프로세스 우선순위

   1. 커널 프로세스 > 일반 프로세스 ⇒ 커널 프로세스 간에 or 일반 프로세스 간에도 우선순위가 존재한다 ⇒ 일반 프로세스의 우선운의는 사용자가 조절 가능 - 관리자만 가능
   2. 입출력 집중 프로세스 > CPU 집중 프로세스
   3. 전면 프로세스 > 후면 프로세스
   4. 대화형 프로세스 > 일괄 처리 프로세스
   5. 우선순위가 높은 프로세스는 더 빨리 자주 실행되는 것을 의미하는데, 커널 프로세스의 우선순위가 더 높기 때문에 커널 프로세스가 먼저 실행되며 작업이 끝날 때까지 계속 CPU 사용

3. CPU 집중 프로세스와 입출력 집중 프로세스

   프로세스 상태 : 생성 → 준비 → 실행 or 대기 → 완료

   프로세스는 CPU를 사용하여 작업을 하는 실행 상태 또는 입출력을 요청하여 완료되기까지 기다리는 대기 상태에 있음

   - CPU 버스트 : CPU를 할당받아 실행하는 작업
   - 입출력 버스트 : 입출력 작업

   1. CPU 집중 프로세스 : CPU를 많이 사용하는 프로세스로 CPU 버스트가 많은 프로세스
   2. 입출력 집중 프로세스 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스로 입출력 버스트가 많은 프로세스

   입출력 요구자에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU 사용 가능 ⇒ CPU 집중 프로세스와 입출력 집중 프로세스가 같이 있을 경우 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것(사이클 훔치기)이 효율적

4. 전면 프로세스와 후면 프로세스

   1. 전면 프로세스 : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스로 현재 입력과 출력을 사용하는 프로세스 ⇒ 상호작용 프로세스
   2. 후면 프로세스 : 사용자와 상호작용이 없는 프로세스 ⇒ 일괄 작업 프로세스

------

### 03. 다중 큐

1. 준비 상태의 다중 큐

   우선순위에 따라 여러 개의 큐를 만들면 프로세스는 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입되어 CPU 스케줄러는 우선순위가 가장 높은 큐의 맨 앞에 있는 프로세스에 CPU를 할당함  ⇒ 준비 상태에 다중 큐를 구현함

   - 프로세스 우선순위 배정 방식
     1. 고정 우선순위 방식 : 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않음 ⇒ 구현하기 쉬움 / 시스템의 변화에 대응하기 어려워 작업 효율 낮음
     2. 변동 우선순위 방식 : 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변함 ⇒ 구현하기 어려움 / 시스템 효율 향상 ⇒ 중요한 자원 사용하는 프로세스의 우선순위를 높여(반전 우선순위) 작업을 빨리 끝내, 다른 프로세스의 작업도 원활히 진행

   준비 큐는 한 번에 하나의 프로세스에 대해 CPU 할당

2. 대기 상태의 다중 큐

   같은 입출력을 기다리는 프로세스의 프로세스 제어 블록은 동일한 입출력 큐에 모아둠

   대기 큐는 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮김 - 입출력이 동시에 끝날 경우 여러 개의 인터럽트 한꺼번에 처리 ⇒ ‘인터럽트 벡터’ 자료구조 사용

------

### 04. 스케줄링 알고리즘

1. 스케줄링 알고리즘 선택 기준

   1. 대기 시간 : 프로세스가 생성된 후 실행되기 전까지 대기하는 시간
   2. 응답 시간 : 첫 작업을 시작한 후 첫 번째 출력(반응)이 나오기까지의 시간
   3. 실행 시간 : 프로세스 작업이 시작된 후 종료되기까지의 시간
   4. 반환 시간 : 대기 시간을 포함하여 실행이 종료될 때까지의 시간 ⇒ 대기 시간 + 실행 시간

   ![img](https://media.vlpt.us/images/im_lily/post/8ce6fa3c-4fef-4ba3-859c-92c133a055c8/image.png)

   스케줄링 알고리즘 성능 비교 시 평균 대기 시간을 봄 ⇒ 모든 프로세스의 대기 시간의 합 / 프로세스의 수

   비선점형 알고리즘의 경우, 효율이 떨어져 지금은 거의 사용되지 않는다

   이 외에도, CPU 사용률, 처리량 평가 기준이 존재하지만, 계산이 어려워 위의 기준을 사용함

2. 비선점형 알고리즘

   - FCFS 스케줄링(선입선출 스케줄링)

     1. 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식으로 하나의 큐로 이루어져있어 모든 프로세스의 우선순위 동일 ⇒ 단순하고 공평함
     2. 콘보이 효과 발생 → 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들의 대기 시간이 길어져 효율성이 떨어지는 현상
     3. 현재 작업 중인 프로세스가 입출력 작업 요청시, CPU가 작업하지 않고 쉬는 시간이 많아져, 작업 효율이 떨어짐

     ![img](https://media.vlpt.us/images/im_lily/post/fd9bada8-45d2-4ad5-a674-e9b51cc1ad29/image.png)

   - SJF 스케줄링(최단 작업 우선 스케줄링 or SPF)

     1. 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
     2. CPU 배정 시 시간이 오래 걸리는 작업이 앞에 있고 간단한 작업이 뒤에 있으면 순서를 바꾸어 실행 ⇒ FCFS 스케줄링의 콘보이 효과 완화하여 시스템 효율 향상
     3. 프로세스의 종료 시간을 파악하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않음
        1. 아사 현상 : 준비 큐에 먼저 도착했음에도 불구하고 작업 시간이 오래 걸리다는 이유로 작업이 계속 연기되는 현상 → 에이징(프로세스가 양보할 수 있는 상한선 정함)으로 완화

     ![img](https://media.vlpt.us/images/im_lily/post/e5f2d1d5-0947-4823-92b9-26eff77385f1/image.png)

   - HRN 스케줄링(최고 응답률 우선 스케줄링)

     1. SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘
     2. 우선순위 = (대기 시간 + CPU 사용 시간) / CPU 사용 시간
     3. 실행 시간이 짧은 프로세스의 우선순위 높게 설정 + 대기 시간 고려 = 아사 현상 완화
     4. 공평성이 위배되어 많이 사용되지 않음

3. 선점형 알고리즘

   - 라운드 로빈 스케줄링

     1. 한 프로세스가 할당받은 시간(타임 슬라이스)동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
     2. 앞의 긴 작업을 무작정 기다리는 콘보이 효과가 줄어듦
     3. 문맥 교환에 따른 추가 시간을 고려하여 타임 슬라이스 적절히 설정 → 프로세스의 반응 시간 뿐만 아니라 시스템 전체의 성능에 영향을 미침
        1. 타임 슬라이스가 큰 경우 : if 타임 슬라이스가 무한대 then FCFS 스케줄링
        2. 타임 슬라이스가 작은 경우 : 문맥 교환에 걸리는 시간 > 작업 시간

     ![img](https://media.vlpt.us/images/im_lily/post/3cf349d9-d9d0-4e8e-be31-1d376c67a444/image.png)

   - SRT 우선 스케줄링(최소 잔류 시간 우선 스케줄링)

     1. SJF 스케줄링 + 라운드 로빈 스케줄링 ⇒ 선점형 SJF 스케줄링
     2. 프로세스의 남은 시간 주기적 계산 + 남은 시간이 더 적은 프로세스와 문맥교환 ⇒ SJF 스케줄링에 없는 작업이 추가됨
     3. 프로세스의 종료 시간을 파악하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않음

     ![img](https://media.vlpt.us/images/im_lily/post/13514a7b-b85b-4c0c-ad88-f52c2dbf6823/image.png)

   - 우선순위 스케줄링

     1. 프로세스의 중요도를 기준으로 우선순위를 반영한 스케줄링
     2. 우선순위는 비선점형 방식과 선점형 방식에 모두 적용 가능
        - 고정 우선순위 알고리즘: 한 번 부여받은 우선순위를 종료시까지 고정 ⇒ 변하는 시스템의 상황을 반영 못해 효율성이 떨어짐
        - 변동 우선순위 알고리즘: 일정 시간마다 우선순위 변화 ⇒ 시스템이 복잡하지만, 시스템의 상황을 반영한 효율적 운영 가능
     3. 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하여 공평성을 위배하고 아사 현상을 일으킴
     4. 준비 큐의 스포레스 순서를 무시 + 프로세스 우선순위 매번 바꿈 ⇒ 오버헤드 발생
     5. 시스템의 효율성보다 프로세스의 중요도에 따라 우선순위가 정해져 각 프로세스가 정상적으로 역할을 할 수 있도록 함

   - 다단계 큐 스케줄링

     1. 우선순위에 따라 준비 큐 여러 개 사용
     2. 프로세스의 우선순위와 작업 형태를 고려하여 스케줄링 가능
     3. 고정형 우선순위를 사용하여 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업 시작 ⇒ 우선순위가 높은 상위 큐 프로세스의 작업이 끝나기 전에는 하위 큐 프로세스 작업 불가능

     ![img](https://media.vlpt.us/images/im_lily/post/67daf92e-73d8-4144-a9f1-c383cd0542f5/image.png)

   - 다단계 피드백 큐 스케줄링 - 변동 우선순위 알고리즘의 대표적인 예

     1. 프로세스가 CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤 ⇒ 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제 완화
     2. 우선순위에 따라 타임 슬라이스 크기가 다름 → 우선순위가 낮아질수록 해당 큐의 타임 슬라이스가 커져 마지막 큐에 있는 프로세스는 무한대의 타임 슬라이스를 얻음(=FCFS)

     ![img](https://media.vlpt.us/images/im_lily/post/3f189550-0add-49fa-b01e-93acec88be2a/image.png)

------

### 05. [심화학습] 인터럽트 처리

1. 인터럽트의 개념

   - 입출력뿐 아니라 시스템을 보호하는데 매우 중요한 ‘인터럽트 처리’
   - 과거: 운영체제가 주기적으로 입출력 장치를 직접 확인해 처리하는 ‘폴링’ 방식
   - 현재: 입출력 완료시, 이벤트 발생시켜 이 사실을 알리는 ‘인터럽트’ 방식

2. 동기적 인터럽트와 비동기적 인터럽트

   1. 동기적 인터럽트(사용자 인터럽트): 프로세스가 실행 중인 명령어로 인해 발생
      1. 프로그램상의 문제 때문에 발생하는 인터럽트
      2. 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
      3. 입출력장치 같은 주변장치의 조작에 의한 인터럽트
      4. 산술 연산 중 발생하는 인터럽트
   2. 비동기적 인터럽트: 실행 중인 명령어와 무관하게 발생
      1. 하드웨어적 오류로 발생하는 인터럽트
      2. ex) 사용자가 직접 작동하는 키보드 인터럽트, 마우스 인터럽트 등

3. 인터럽트 처리 과정

   인터럽트 번호와 그 번호에 붙어 있는 함수의 쌍으로 이루어져, 번호에 따른 함수 동작 방식

   시스템에는 많은 인터럽트 존재 - 고유번호를 가짐(윈도우에선 IRQ)

   ![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6cd610df-950d-4c13-b1e2-f95a1427607d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211229%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211229T012753Z&X-Amz-Expires=86400&X-Amz-Signature=d723e6ebe14d56b73b3b1097b0b358b0e500a22fd9436c81635b44a4aaca1077&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

   한순간에 여러 개가 동시에 발생하는 인터럽트 - 이를 하나로 묶어 처리하는 ‘인터럽트 벡터’

   인터럽트 발생시, 인터럽트 벡터의 번호의 인덱스 요소가 0에서 1로 변화 ⇒ 인터럽트 발생시 어떤 일을 처리할 것인지 정의된 ‘인터럽트 핸들러’ 실행

4. 인터럽트와 이중 모드

   프로세스는 크게 ‘커널 프로세스’와 ‘사용자 프로세스’로 나뉨

   - 커널 모드 - 운영체제와 관련된 커널 프로세스가 실행되는 상태
   - 사용자 모드 - 사용자 프로세스가 실행되는 상태

   하지만, 사용자 프로세스가 커널의 기능을 사용하려면 시스템 호출을 통해 커널 프로세스에 작업을 요청해야함 - 이 때 사용자 모드에서 커널 모드로 전환되는 것과 같이 운영체제가 두 모드를 전환하며 일을 처리하는 ‘이중 모드’가 발생함

   1. 이중 모드는 운영체제가 자원을 보호하기 위해 사용하는 기법 - 사용자 프로세스가 시스템 자원에 직접 접근시 문제 발생하기 때문
   2. 사용자는 시스템 호출을 사용할 수 있고, API가 준비해놓은 다양한 함수를 이용해 시스템 자원에 접근

   - 사용자가 커널 모드로 진입하는 두 가지 경우
     1. 시스템 호출을 사용한 경우 - 자발적(voluntary)
     2. 인터럽트를 발생시킨 경우 - 비자발적(non-voluntary)

------

Reference

- https://velog.io/@im_lily/%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Chapter04